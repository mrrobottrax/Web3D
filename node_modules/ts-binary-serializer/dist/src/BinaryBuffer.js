"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Float16_1 = require("./Float16");
var TypeMetaClass_1 = require("./TypeMetaClass");
var DataType_1 = require("./DataType");
var VariantEncoding_1 = require("./VariantEncoding");
var BinaryBufferOptions = /** @class */ (function () {
    function BinaryBufferOptions() {
        this.fastUTF8string = true;
    }
    return BinaryBufferOptions;
}());
exports.BinaryBufferOptions = BinaryBufferOptions;
var BinaryBuffer = /** @class */ (function () {
    function BinaryBuffer(options) {
        this.m_arrayBufferCurrentSize = BinaryBuffer.DEFAULT_BUFFER_SIZE;
        this.m_pos = 0;
        if (options == null) {
            options = new BinaryBufferOptions();
        }
        this.m_options = options;
    }
    Object.defineProperty(BinaryBuffer.prototype, "options", {
        get: function () { return this.m_options; },
        enumerable: true,
        configurable: true
    });
    BinaryBuffer.initialize = function () {
        for (var t in DataType_1.DataType) {
            if (!isNaN(Number(t)))
                continue;
            var v = DataType_1.DataType[t];
            this.WriteFuncMap[v] = "write" + t;
            this.ReadFuncMap[v] = "read" + t;
        }
    };
    Object.defineProperty(BinaryBuffer.prototype, "pos", {
        get: function () {
            return this.m_pos;
        },
        enumerable: true,
        configurable: true
    });
    BinaryBuffer.create = function (options) {
        var buffer = new BinaryBuffer(options);
        var uint8ary = new Uint8Array(BinaryBuffer.DEFAULT_BUFFER_SIZE);
        buffer.m_arrayBuffer = uint8ary;
        buffer.m_view = new DataView(uint8ary.buffer);
        if (!buffer.options.fastUTF8string) {
            buffer.writeString = buffer.writeUTF8Str;
            buffer.readString = buffer.readUTF8Str;
        }
        return buffer;
    };
    BinaryBuffer.prototype.checkBufferExpand = function (appendSize) {
        if (appendSize === void 0) { appendSize = 8; }
        var cursize = this.m_arrayBufferCurrentSize;
        if (this.m_pos + appendSize >= cursize) {
            var tarsize = cursize + appendSize;
            while (cursize < tarsize) {
                cursize = cursize << 1;
            }
            var curbuf = this.m_arrayBuffer;
            var newbuf = new Uint8Array(cursize);
            newbuf.set(curbuf, 0);
            this.m_arrayBuffer = newbuf;
            this.m_arrayBufferCurrentSize = cursize;
            this.m_view = new DataView(newbuf.buffer, 0, cursize);
        }
    };
    BinaryBuffer.createWithView = function (arybuffer, offset, bytesize, options) {
        var buffer = new BinaryBuffer(options);
        if (arybuffer instanceof Uint8Array) {
            buffer.m_arrayBuffer = arybuffer;
            buffer.m_view = new DataView(arybuffer.buffer, offset, bytesize);
        }
        else {
            buffer.m_arrayBuffer = new Uint8Array(arybuffer);
            buffer.m_view = new DataView(arybuffer, offset, bytesize);
        }
        buffer.m_pos = offset;
        if (!buffer.options.fastUTF8string) {
            buffer.writeString = buffer.writeUTF8Str;
            buffer.readString = buffer.readUTF8Str;
        }
        return buffer;
    };
    BinaryBuffer.prototype.writeProperty = function (val, p) {
        var type = p.datatype;
        var isary = p.isArray;
        var tmc = p.pclass;
        if (val == null) {
            this.writeType(DataType_1.DataType.Null);
            return;
        }
        this.writeType(type);
        var f = this[BinaryBuffer.WriteFuncMap[type]];
        var isobj = type == DataType_1.DataType.Object;
        var ismap = type == DataType_1.DataType.Map;
        if (!isary) {
            this.checkBufferExpand(8);
            if (type == DataType_1.DataType.TypedArray) {
                Reflect.apply(f, this, [val, tmc]);
            }
            else if (isobj) {
                Reflect.apply(f, this, [val, tmc]);
            }
            else if (ismap) {
                this.writeMap(val, tmc);
            }
            else {
                Reflect.apply(f, this, [val]);
            }
            return;
        }
        if (!Array.isArray(val)) {
            var msg = "target property: " + val + " is not an array.";
            throw new Error(msg);
        }
        var ary = val;
        var arylen = ary.length;
        this.checkBufferExpand(arylen * 8 + 4);
        this.writeVarint32(arylen);
        if (isobj) {
            for (var i = 0; i < arylen; i++) {
                Reflect.apply(f, this, [ary[i], tmc]);
            }
        }
        else if (ismap) {
            for (var i = 0; i < arylen; i++) {
                this.writeMap(ary[i], tmc);
            }
        }
        else {
            for (var i = 0; i < arylen; i++) {
                f.call(this, ary[i], tmc);
            }
        }
    };
    BinaryBuffer.prototype.readProperty = function (p) {
        var ptype = p.datatype;
        var t = this.readType();
        if (t == DataType_1.DataType.Null)
            return null;
        if (t != ptype)
            throw new Error("[property: " + p.key + "] type mismatch data:" + DataType_1.DataType[t] + "[" + t + "] - meta:" + DataType_1.DataType[ptype] + "[" + ptype + "]");
        var f = this[BinaryBuffer.ReadFuncMap[ptype]];
        var isobj = ptype == DataType_1.DataType.Object;
        var ismap = ptype == DataType_1.DataType.Map;
        var isary = p.isArray;
        var tmc = p.pclass;
        if (!isary) {
            if (ptype == DataType_1.DataType.TypedArray) {
                return f.call(this, tmc);
            }
            else if (isobj) {
                if (tmc == null) {
                    throw new Error('tmc is null');
                }
                return f.call(this, tmc);
            }
            else if (ismap) {
                if (tmc == null)
                    throw new Error("read property tmc missing: " + ptype);
                return this.readMap(tmc);
            }
            else {
                return f.call(this, null);
            }
        }
        var arylen = this.readVarint32();
        if (arylen == 0)
            return [];
        var ary = [];
        if (isobj) {
            for (var i = 0; i < arylen; i++) {
                ary.push(f.call(this, tmc));
            }
        }
        else if (ismap) {
            if (tmc == null)
                throw new Error("read property tmc missing: " + ptype);
            for (var i = 0; i < arylen; i++) {
                ary.push(this.readMap(tmc));
            }
        }
        else {
            for (var i = 0; i < arylen; i++) {
                ary.push(f.call(this, tmc));
            }
        }
        return ary;
    };
    BinaryBuffer.prototype.writeMap = function (o, tmc) {
        if (o == null) {
            this.writeUint16(0);
            return;
        }
        var ownnames = Object.getOwnPropertyNames(o);
        ownnames.sort();
        if (tmc == null)
            throw new Error("type not found for:" + o);
        var len = ownnames.length;
        if (len > 65535)
            throw new Error("map size exceed!");
        this.writeUint16(len);
        for (var t = 0, len_1 = ownnames.length; t < len_1; t++) {
            var key = ownnames[t];
            this.writeString(key);
            var v = o[key];
            if (v == null) {
                this.writeBool(false);
            }
            else {
                this.writeBool(true);
                if (tmc instanceof TypeMetaClass_1.TypeMetaClass) {
                    this.writeObject(v, tmc);
                }
                else {
                    var f = this[BinaryBuffer.WriteFuncMap[tmc]];
                    f.call(this, v);
                }
            }
        }
    };
    BinaryBuffer.prototype.readMap = function (tmc) {
        var len = this.readUint16();
        if (len == 0)
            return null;
        var ret = {};
        for (var t = 0; t < len; t++) {
            var key = this.readString();
            if (key == null)
                throw new Error("key is null");
            var notnull = this.readBool();
            if (notnull) {
                if (tmc instanceof TypeMetaClass_1.TypeMetaClass) {
                    ret[key] = this.readObject(tmc);
                }
                else {
                    var f = this[BinaryBuffer.ReadFuncMap[tmc]];
                    ret[key] = f.call(this, null);
                }
            }
            else {
                ret[key] = null;
            }
        }
        return ret;
    };
    BinaryBuffer.prototype.writeFloat16 = function (v) {
        var view = this.m_view;
        var p = this.m_pos;
        var d = Float16_1.Float16.Float16ToByte(v);
        view.setUint16(p, d);
        this.m_pos += 2;
    };
    BinaryBuffer.prototype.readFloat16 = function () {
        var view = this.m_view;
        var d = view.getUint16(this.m_pos);
        var ret = Float16_1.Float16.ByteToFloat16(d);
        this.m_pos += 2;
        return ret;
    };
    BinaryBuffer.prototype.writeFloat32 = function (v) {
        var view = this.m_view;
        var p = this.m_pos;
        view.setFloat32(p, v);
        this.m_pos += 4;
    };
    BinaryBuffer.prototype.readFloat32 = function () {
        var view = this.m_view;
        var ret = view.getFloat32(this.m_pos);
        this.m_pos += 4;
        return ret;
    };
    BinaryBuffer.prototype.writeFloat64 = function (v) {
        var view = this.m_view;
        var p = this.m_pos;
        try {
            view.setFloat64(p, v);
        }
        catch (e) {
            console.log(p, this.m_arrayBufferCurrentSize);
            throw e;
        }
        this.m_pos += 8;
    };
    BinaryBuffer.prototype.readFloat64 = function () {
        var view = this.m_view;
        var ret = view.getFloat64(this.m_pos);
        this.m_pos += 8;
        return ret;
    };
    BinaryBuffer.prototype.writeVarint32 = function (v) {
        if (v > VariantEncoding_1.Variant.MAX_INT || v < VariantEncoding_1.Variant.MIN_INT) {
            throw new Error("variant32 value range exceeded.");
            // this.writeInt32(v);
        }
        else {
            var ab = this.m_arrayBuffer;
            var p = this.m_pos;
            v = v >= 0 ? v * 2 : v * -2 - 1;
            var BYTE = 128;
            while (v >= BYTE) {
                var b = (v & 0xFF) | BYTE;
                ab[p] = b;
                p++;
                v = (v >> 7);
            }
            ab[p] = v;
            this.m_pos = p + 1;
        }
    };
    BinaryBuffer.prototype.readVarint32 = function () {
        var ab = this.m_arrayBuffer;
        var p = this.m_pos;
        var b = ab[p];
        var index = 0;
        var v = 0;
        while ((b & 128) > 0) {
            v += (b & 127) << (index * 7);
            index++;
            b = ab[p + index];
        }
        v += (b & 127) << (index * 7);
        this.m_pos += (index + 1);
        return v & 1 ? (v + 1) / -2 : v / 2;
        ;
    };
    BinaryBuffer.prototype.writeUVarint32 = function (v) {
        if (v > VariantEncoding_1.Variant.MAX_UINT || v < 0) {
            throw new Error("variant32 value range exceeded. " + v);
            // this.writeInt32(v);
        }
        else {
            var ab = this.m_arrayBuffer;
            var p = this.m_pos;
            var BYTE = 128;
            while (v >= BYTE) {
                var b = (v & 0xFF) | BYTE;
                ab[p] = b;
                p++;
                v = (v >> 7);
            }
            ab[p] = v;
            this.m_pos = p + 1;
        }
    };
    BinaryBuffer.prototype.readUVarint32 = function () {
        var ab = this.m_arrayBuffer;
        var p = this.m_pos;
        var b = ab[p];
        var index = 0;
        var v = 0;
        while ((b & 128) > 0) {
            v += (b & 127) << (index * 7);
            index++;
            b = ab[p + index];
        }
        v += (b & 127) << (index * 7);
        this.m_pos += (index + 1);
        return v;
    };
    BinaryBuffer.prototype.writeTypedArray = function (v, tmc) {
        var vlen = v.length;
        this.writeInt32(vlen);
        this.checkBufferExpand(v.byteLength);
        var cons = tmc.prototype.constructor;
        var bytesPerElement = tmc.prototype['BYTES_PER_ELEMENT'];
        var f = BinaryBuffer.TypedArrayWriteMap[cons.name];
        var view = this.m_view;
        var pos = this.m_pos;
        var len = v.length;
        for (var t = 0; t < len; t++) {
            Reflect.apply(f, view, [pos, v[t]]);
            pos += bytesPerElement;
        }
        this.m_pos = pos;
    };
    BinaryBuffer.prototype.readTypedArray = function (tmc) {
        var view = this.m_view;
        var vlen = this.readInt32();
        var cons = tmc.prototype.constructor;
        var f = BinaryBuffer.TypedArrrayReadMap[cons.name];
        var tarray = new cons(vlen);
        var bytesPerElement = tmc.prototype['BYTES_PER_ELEMENT'];
        var pos = this.m_pos;
        for (var t = 0; t < vlen; t++) {
            tarray[t] = Reflect.apply(f, view, [pos]);
            pos += bytesPerElement;
        }
        this.m_pos = pos;
        return tarray;
    };
    BinaryBuffer.prototype.writeInt8 = function (v) {
        var view = this.m_view;
        var p = this.m_pos;
        view.setInt8(p, v);
        this.m_pos++;
    };
    BinaryBuffer.prototype.readInt8 = function () {
        var view = this.m_view;
        var ret = view.getInt8(this.m_pos);
        this.m_pos += 1;
        return ret;
    };
    BinaryBuffer.prototype.writeUint8 = function (v) {
        var view = this.m_view;
        var p = this.m_pos;
        view.setUint8(p, v);
        this.m_pos++;
    };
    BinaryBuffer.prototype.readUint8 = function () {
        var view = this.m_view;
        var ret = view.getUint8(this.m_pos);
        this.m_pos += 1;
        return ret;
    };
    BinaryBuffer.prototype.writeInt16 = function (v) {
        var view = this.m_view;
        var p = this.m_pos;
        view.setInt16(p, v);
        this.m_pos += 2;
    };
    BinaryBuffer.prototype.readInt16 = function () {
        var view = this.m_view;
        var ret = view.getInt16(this.m_pos);
        this.m_pos += 2;
        return ret;
    };
    BinaryBuffer.prototype.writeUint16 = function (v) {
        var view = this.m_view;
        var p = this.m_pos;
        view.setUint16(p, v);
        this.m_pos += 2;
    };
    BinaryBuffer.prototype.readUint16 = function () {
        var view = this.m_view;
        var ret = view.getUint16(this.m_pos);
        this.m_pos += 2;
        return ret;
    };
    BinaryBuffer.prototype.writeInt32 = function (v) {
        var view = this.m_view;
        var p = this.m_pos;
        view.setInt32(p, v);
        this.m_pos += 4;
    };
    BinaryBuffer.prototype.readInt32 = function () {
        var view = this.m_view;
        var ret = view.getInt32(this.m_pos);
        this.m_pos += 4;
        return ret;
    };
    BinaryBuffer.prototype.writeUint32 = function (v) {
        var view = this.m_view;
        var p = this.m_pos;
        view.setUint32(p, v);
        this.m_pos += 4;
    };
    BinaryBuffer.prototype.readUint32 = function () {
        var view = this.m_view;
        var ret = view.getUint32(this.m_pos);
        this.m_pos += 4;
        return ret;
    };
    BinaryBuffer.prototype.writeBool = function (b) {
        var view = this.m_view;
        var p = this.m_pos;
        view.setUint8(p, b
            ? 1
            : 0);
        this.m_pos++;
    };
    BinaryBuffer.prototype.readBool = function () {
        var view = this.m_view;
        var ret = view.getUint8(this.m_pos);
        this.m_pos++;
        return ret == 1;
    };
    // hack implement https://stackoverflow.com/questions/17191945/conversion-between-utf-8-arraybuffer-and-string
    BinaryBuffer.prototype.writeString = function (str) {
        if (str == null) {
            this.writeVarint32(-1);
            return;
        }
        if (str === '') {
            this.writeVarint32(0);
            return;
        }
        var utf8 = unescape(encodeURIComponent(str));
        var len = utf8.length;
        this.writeVarint32(len);
        this.checkBufferExpand(len);
        var view = this.m_view;
        var p = this.m_pos;
        for (var t = 0; t < len; t++) {
            view.setUint8(p++, utf8.charCodeAt(t));
        }
        this.m_pos = p;
    };
    BinaryBuffer.prototype.readString = function () {
        var len = this.readVarint32();
        if (len == -1)
            return null;
        if (len == 0)
            return '';
        var ary = new Array(len);
        var s = this.m_pos;
        var buf = this.m_arrayBuffer;
        for (var t = 0; t < len; t++) {
            ary[t] = buf[s++];
        }
        var ustr = String.fromCharCode.apply(String, ary);
        this.m_pos = s;
        return decodeURIComponent(escape(ustr));
    };
    BinaryBuffer.prototype.writeUTF8Str = function (str) {
        if (str == null) {
            this.writeVarint32(-1);
            return;
        }
        if (str === '') {
            this.writeVarint32(0);
            return;
        }
        var len = str.length;
        this.writeVarint32(len);
        this.checkBufferExpand(len * 4);
        var view = this.m_view;
        var p = this.m_pos;
        for (var t = 0; t < len; t++) {
            var c = str.charCodeAt(t);
            if (c < 0x80) {
                view.setUint8(p++, c);
            }
            else if (c < 0x800) {
                view.setUint8(p++, (c >> 6) | 0xc0);
                view.setUint8(p++, 0x80 | (c & 0x3f));
            }
            else if (c < 0x10000) {
                view.setUint8(p++, 0xe0 | (c >> 12));
                view.setUint8(p++, 0x80 | ((c >> 6) & 0x3f));
                view.setUint8(p++, 0x80 | (c & 0x3f));
            }
            else {
                view.setUint8(p++, 0xf0 | (c >> 18));
                view.setUint8(p++, 0x80 | ((c >> 12) & 0x3f));
                view.setUint8(p++, 0x80 | ((c >> 6) & 0x3f));
                view.setUint8(p++, 0x80 | (c & 0x3f));
            }
        }
        this.m_pos = p;
    };
    BinaryBuffer.prototype.readUTF8Str = function () {
        var len = this.readVarint32();
        if (len == -1) {
            return null;
        }
        if (len == 0)
            return '';
        var charary = new Array(len);
        for (var t = 0; t < len; t++) {
            var c0 = this.readUint8();
            if (c0 >> 7 == 0) {
                charary[t] = c0;
            }
            else if (c0 >> 5 == 6) {
                var c1 = this.readUint8();
                charary[t] = ((c0 & 0x1F) << 6) | (c1 & 0x3F);
            }
            else if (c0 >> 4 == 14) {
                var c1 = this.readUint8();
                var c2 = this.readUint8();
                charary[t] = ((c0 & 0x0F) << 12) | ((c1 & 0x3F) << 6) | (c2 & 0x3F);
            }
            else {
                var c1 = this.readUint8();
                var c2 = this.readUint8();
                var c3 = this.readUint8();
                charary[t] = ((c0 & 0x07) << 18) | ((c1 & 0x3F) << 12) | ((c2 & 0x3F) << 6) | (c3 & 0x3F);
            }
        }
        return String.fromCharCode.apply(String, charary);
    };
    BinaryBuffer.prototype.writeType = function (t) {
        this.writeUint8(t);
    };
    BinaryBuffer.prototype.readType = function () {
        var ret = this.readUint8();
        return ret;
    };
    BinaryBuffer.prototype.writeObject = function (o, tmc) {
        this.serialize(tmc, o);
    };
    BinaryBuffer.prototype.readObject = function (tmc) {
        var tar = Object.create(tmc.prototype);
        this.deserialize(tar, tmc);
        return tar;
    };
    BinaryBuffer.prototype.serialize = function (mc, obj) {
        mc.sortProperty();
        var properties = mc.properties;
        for (var i = 0, len = properties.length; i < len; i++) {
            var p = properties[i];
            try {
                this.writeProperty(obj[p.key], p);
            }
            catch (e) {
                console.error("property meta class of " + p.key + " is null, for type: " + DataType_1.DataType[p.datatype]);
                throw e;
            }
        }
    };
    BinaryBuffer.prototype.deserialize = function (tar, mc) {
        if (mc == null) {
            throw new Error('typeMetaClass is null');
        }
        mc.sortProperty();
        var properties = mc.properties;
        for (var i = 0, len = properties.length; i < len; i++) {
            var p = properties[i];
            var val = this.readProperty(p);
            tar[p.key] = val;
        }
        return tar;
    };
    BinaryBuffer.DEFAULT_BUFFER_SIZE = 512;
    BinaryBuffer.WriteFuncMap = {};
    BinaryBuffer.ReadFuncMap = {};
    BinaryBuffer.TypedArrayWriteMap = {
        'Uint8Array': DataView.prototype.setUint8,
        'Uint16Array': DataView.prototype.setUint16,
        'Uint32Array': DataView.prototype.setUint32,
        'Int8Array': DataView.prototype.setInt8,
        'Int16Array': DataView.prototype.setInt16,
        'Int32Array': DataView.prototype.setInt32,
        'Float32Array': DataView.prototype.setFloat32,
        'Float64Array': DataView.prototype.setFloat64,
    };
    BinaryBuffer.TypedArrrayReadMap = {
        'Uint8Array': DataView.prototype.getUint8,
        'Uint16Array': DataView.prototype.getUint16,
        'Uint32Array': DataView.prototype.getUint32,
        'Int8Array': DataView.prototype.getInt8,
        'Int16Array': DataView.prototype.getInt16,
        'Int32Array': DataView.prototype.getInt32,
        'Float32Array': DataView.prototype.getFloat32,
        'Float64Array': DataView.prototype.getFloat64,
    };
    return BinaryBuffer;
}());
exports.BinaryBuffer = BinaryBuffer;
BinaryBuffer.initialize();
